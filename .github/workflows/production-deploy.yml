name: Production CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  AWS_REGION: us-west-2
  PROJECT_NAME: kaitech
  TERRAFORM_VERSION: 1.6.0
  
jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      terraform: ${{ steps.changes.outputs.terraform }}
      services: ${{ steps.changes.outputs.services }}
      frontend: ${{ steps.changes.outputs.frontend }}
      nginx: ${{ steps.changes.outputs.nginx }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            terraform:
              - 'terraform/**'
            services:
              - 'services/**'
            frontend:
              - 'frontend/**'
            nginx:
              - 'nginx/**'

  test-services:
    name: Test Services
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.services == 'true'
    
    strategy:
      fail-fast: false
      matrix:
        service: [news-service, ai-service]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Create cache key
      id: cache-key
      run: echo "cache-key=${{ runner.os }}-pip-${{ matrix.service }}-${{ hashFiles('services/${{ matrix.service }}/requirements.txt') }}" >> $GITHUB_OUTPUT
        
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ steps.cache-key.outputs.cache-key }}
        restore-keys: |
          ${{ runner.os }}-pip-${{ matrix.service }}-
          
    - name: Install dependencies
      run: |
        cd services/${{ matrix.service }}
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio pytest-mock httpx
        
    - name: Create test config
      run: |
        cd services/${{ matrix.service }}
        cat > test_config.py << EOF
        import os
        os.environ['TESTING'] = 'true'
        os.environ['REDIS_URL'] = 'redis://localhost:6379'
        os.environ['DATABASE_URL'] = 'postgresql://test:test@localhost:5432/test'
        EOF
        
    - name: Run unit tests
      run: |
        cd services/${{ matrix.service }}
        python -m pytest tests/ -v --cov=. --cov-report=xml --cov-report=term-missing --tb=short
      env:
        TESTING: true
        REDIS_URL: redis://localhost:6379
        DATABASE_URL: postgresql://test:test@localhost:5432/test
        
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./services/${{ matrix.service }}/coverage.xml
        flags: ${{ matrix.service }}
        name: codecov-${{ matrix.service }}
        fail_ci_if_error: false

  lint-and-security:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.services == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install tools
      run: |
        pip install --upgrade pip
        pip install black isort flake8 mypy bandit safety
        
    - name: Check formatting with Black
      run: black --check --diff services/
      
    - name: Check import sorting with isort
      run: isort --check-only --diff services/
      
    - name: Lint with flake8
      run: flake8 services/ --max-line-length=88 --extend-ignore=E203,W503,E501
      
    - name: Type check with mypy
      run: mypy services/ --ignore-missing-imports --no-strict-optional
      continue-on-error: true
      
    - name: Security check with bandit
      run: bandit -r services/ -f json -o bandit-report.json
      continue-on-error: true
      
    - name: Upload security scan results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: security-scan-results
        path: bandit-report.json

  docker-security-scan:
    name: Docker Security Scan
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.services == 'true' || needs.changes.outputs.frontend == 'true'
    
    strategy:
      matrix:
        service: [news-service, ai-service]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Build Docker image
      run: |
        cd services/${{ matrix.service }}
        docker build -t ${{ matrix.service }}:test .
        
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ matrix.service }}:test'
        format: 'sarif'
        output: 'trivy-results-${{ matrix.service }}.sarif'
        
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results-${{ matrix.service }}.sarif'
        category: 'trivy-${{ matrix.service }}'

  build-and-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: [test-services, lint-and-security]
    if: |
      always() && 
      (needs.test-services.result == 'success' || needs.test-services.result == 'skipped') &&
      (needs.lint-and-security.result == 'success' || needs.lint-and-security.result == 'skipped') &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - service: web
            dockerfile: ./frontend/Dockerfile
            context: ./frontend
            condition: needs.changes.outputs.frontend
          - service: news-api
            dockerfile: ./services/news-service/Dockerfile
            context: ./services/news-service
            condition: needs.changes.outputs.services
          - service: ai-api
            dockerfile: ./services/ai-service/Dockerfile
            context: ./services/ai-service
            condition: needs.changes.outputs.services
            
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      if: matrix.condition == 'true'
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      if: matrix.condition == 'true'
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      if: matrix.condition == 'true'
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Set up Docker Buildx
      if: matrix.condition == 'true'
      uses: docker/setup-buildx-action@v3
      
    - name: Extract metadata
      id: meta
      if: matrix.condition == 'true'
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}-${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value={{date 'YYYYMMDD-HHmmss'}}
          
    - name: Build and push Docker image
      if: matrix.condition == 'true'
      uses: docker/build-push-action@v5
      with:
        context: ${{ matrix.context }}
        file: ${{ matrix.dockerfile }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha,scope=${{ matrix.service }}
        cache-to: type=gha,mode=max,scope=${{ matrix.service }}
        platforms: linux/amd64
        build-args: |
          BUILDKIT_INLINE_CACHE=1

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [changes, build-and-push]
    if: |
      always() &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped') &&
      (needs.changes.outputs.terraform == 'true' || github.ref == 'refs/heads/main')
    
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    
    outputs:
      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Terraform Format Check
      run: |
        cd terraform
        terraform fmt -check -recursive
        
    - name: Terraform Init
      run: |
        cd terraform
        terraform init -input=false
        
    - name: Terraform Validate
      run: |
        cd terraform
        terraform validate
        
    - name: Terraform Plan
      id: tf-plan
      run: |
        cd terraform
        export TF_VAR_environment="${{ github.ref == 'refs/heads/main' && 'prod' || 'staging' }}"
        export TF_VAR_domain_name="${{ secrets.DOMAIN_NAME }}"
        export TF_VAR_news_api_key="${{ secrets.NEWS_API_KEY }}"
        export TF_VAR_openai_api_key="${{ secrets.OPENAI_API_KEY }}"
        export TF_VAR_grok_api_key="${{ secrets.GROK_API_KEY }}"
        
        terraform plan -detailed-exitcode -no-color -out=tfplan -input=false
        echo "exitcode=$?" >> $GITHUB_OUTPUT
        
    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v3
      with:
        name: terraform-plan
        path: terraform/tfplan
        retention-days: 5

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [terraform-plan]
    if: |
      github.ref == 'refs/heads/main' && 
      needs.terraform-plan.outputs.tfplanExitCode == 2
    
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Download Terraform Plan
      uses: actions/download-artifact@v3
      with:
        name: terraform-plan
        path: terraform/
        
    - name: Terraform Init
      run: |
        cd terraform
        terraform init -input=false
        
    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve -input=false tfplan
        
    - name: Generate Terraform Outputs
      id: tf-outputs
      run: |
        cd terraform
        terraform output -json > ../terraform-outputs.json
        cat ../terraform-outputs.json
        
    - name: Upload Terraform Outputs
      uses: actions/upload-artifact@v3
      with:
        name: terraform-outputs
        path: terraform-outputs.json
        retention-days: 30

  deploy-services:
    name: Deploy Services
    runs-on: ubuntu-latest
    needs: [terraform-apply]
    if: github.ref == 'refs/heads/main' && needs.terraform-apply.result == 'success'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Download Terraform Outputs
      uses: actions/download-artifact@v3
      with:
        name: terraform-outputs
        
    - name: Extract deployment info
      id: deploy-info
      run: |
        CLUSTER_NAME=$(jq -r '.ecs_cluster_name.value // empty' terraform-outputs.json)
        APP_URL=$(jq -r '.application_url.value // empty' terraform-outputs.json)
        
        echo "cluster-name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
        echo "app-url=$APP_URL" >> $GITHUB_OUTPUT
        
        if [ -z "$CLUSTER_NAME" ]; then
          echo "Error: Could not extract cluster name from terraform outputs"
          exit 1
        fi
        
    - name: Update ECS Services
      run: |
        CLUSTER_NAME="${{ steps.deploy-info.outputs.cluster-name }}"
        
        echo "Updating services in cluster: $CLUSTER_NAME"
        
        # Force new deployment for each service
        aws ecs update-service \
          --cluster "$CLUSTER_NAME" \
          --service "${{ env.PROJECT_NAME }}-web" \
          --force-new-deployment \
          --no-cli-pager || echo "Web service update failed or doesn't exist"
          
        aws ecs update-service \
          --cluster "$CLUSTER_NAME" \
          --service "${{ env.PROJECT_NAME }}-news-api" \
          --force-new-deployment \
          --no-cli-pager || echo "News API service update failed or doesn't exist"
          
        aws ecs update-service \
          --cluster "$CLUSTER_NAME" \
          --service "${{ env.PROJECT_NAME }}-ai-api" \
          --force-new-deployment \
          --no-cli-pager || echo "AI API service update failed or doesn't exist"
        
    - name: Wait for deployment completion
      timeout-minutes: 15
      run: |
        CLUSTER_NAME="${{ steps.deploy-info.outputs.cluster-name }}"
        
        echo "Waiting for services to stabilize..."
        
        # Wait for each service to become stable
        aws ecs wait services-stable \
          --cluster "$CLUSTER_NAME" \
          --services "${{ env.PROJECT_NAME }}-web" || echo "Web service stabilization timeout"
          
        aws ecs wait services-stable \
          --cluster "$CLUSTER_NAME" \
          --services "${{ env.PROJECT_NAME }}-news-api" || echo "News API service stabilization timeout"
          
        aws ecs wait services-stable \
          --cluster "$CLUSTER_NAME" \
          --services "${{ env.PROJECT_NAME }}-ai-api" || echo "AI API service stabilization timeout"

  health-check:
    name: Post-Deployment Health Check
    runs-on: ubuntu-latest
    needs: [deploy-services]
    if: always() && needs.deploy-services.result == 'success'
    
    steps:
    - name: Download Terraform Outputs
      uses: actions/download-artifact@v3
      with:
        name: terraform-outputs
        
    - name: Extract URLs
      id: urls
      run: |
        APP_URL=$(jq -r '.application_url.value // "https://example.com"' terraform-outputs.json)
        NEWS_API_URL=$(jq -r '.news_api_url.value // "https://example.com/api/news"' terraform-outputs.json)
        AI_API_URL=$(jq -r '.ai_api_url.value // "https://example.com/api/ai"' terraform-outputs.json)
        
        echo "app-url=$APP_URL" >> $GITHUB_OUTPUT
        echo "news-api-url=$NEWS_API_URL" >> $GITHUB_OUTPUT
        echo "ai-api-url=$AI_API_URL" >> $GITHUB_OUTPUT
        
    - name: Wait for services to be ready
      run: sleep 120
      
    - name: Health check with retry
      run: |
        check_health() {
          local url=$1
          local name=$2
          local max_attempts=5
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts: Checking $name health..."
            
            if curl -f -s --max-time 30 "$url/health" > /dev/null 2>&1; then
              echo "✅ $name is healthy"
              return 0
            fi
            
            echo "❌ $name health check failed (attempt $attempt/$max_attempts)"
            attempt=$((attempt + 1))
            
            if [ $attempt -le $max_attempts ]; then
              echo "Waiting 30 seconds before retry..."
              sleep 30
            fi
          done
          
          echo "🚨 $name health check failed after $max_attempts attempts"
          return 1
        }
        
        # Check each service
        check_health "${{ steps.urls.outputs.app-url }}" "Main Application" || exit_code=1
        check_health "${{ steps.urls.outputs.news-api-url }}" "News API" || exit_code=1
        check_health "${{ steps.urls.outputs.ai-api-url }}" "AI API" || exit_code=1
        
        if [ "${exit_code:-0}" -eq 1 ]; then
          echo "🚨 Some health checks failed"
          exit 1
        fi
        
        echo "🎉 All services are healthy!"

  notification:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [health-check, deploy-services]
    if: always() && github.ref == 'refs/heads/main'
    
    steps:
    - name: Download Terraform Outputs
      uses: actions/download-artifact@v3
      with:
        name: terraform-outputs
      if: needs.deploy-services.result == 'success'
      
    - name: Send success notification
      if: needs.health-check.result == 'success'
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: |
          🚀 KaiTech production deployment successful!
          
          📱 Application: $(jq -r '.application_url.value // "N/A"' terraform-outputs.json 2>/dev/null)
          📰 News API: $(jq -r '.news_api_url.value // "N/A"' terraform-outputs.json 2>/dev/null)
          🤖 AI API: $(jq -r '.ai_api_url.value // "N/A"' terraform-outputs.json 2>/dev/null)
          
          📊 Commit: ${{ github.sha }}
          🌿 Branch: ${{ github.ref_name }}
          👤 Author: ${{ github.actor }}
          🕐 Time: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        
    - name: Send failure notification
      if: needs.health-check.result == 'failure' || needs.deploy-services.result == 'failure'
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        text: |
          ❌ KaiTech production deployment failed!
          
          📊 Commit: ${{ github.sha }}
          🌿 Branch: ${{ github.ref_name }}
          👤 Author: ${{ github.actor }}
          🕐 Time: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          Please check the GitHub Actions logs for details:
          ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}